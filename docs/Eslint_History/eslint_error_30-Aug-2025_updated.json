[
  {
    "filePath": "/Users/chun/Documents/PennineWMS/online-stock-control-system/app/(app)/admin/hooks/useGraphQLDataUpdate.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "message": "Definition for rule '@typescript-eslint/no-unused-vars' was not found.",
        "line": 151,
        "column": 3,
        "endLine": 151,
        "endColumn": 64,
        "severity": 2,
        "nodeType": null
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'config.fields'. Either include it or remove the dependency array.",
        "line": 215,
        "column": 5,
        "nodeType": "ArrayExpression",
        "endLine": 215,
        "endColumn": 7,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [config.fields]",
            "fix": { "range": [6640, 6642], "text": "[config.fields]" }
          }
        ]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'config.primaryKey'. Either include it or remove the dependency array.",
        "line": 464,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 464,
        "endColumn": 89,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [config.primaryKey, config.entityType, updateProduct, showOverlay, onSuccess, updateSupplier, onError]",
            "fix": {
              "range": [14945, 15028],
              "text": "[config.primaryKey, config.entityType, updateProduct, showOverlay, onSuccess, updateSupplier, onError]"
            }
          }
        ]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback has a missing dependency: 'config.fields'. Either include it or remove the dependency array.",
        "line": 534,
        "column": 8,
        "nodeType": "ArrayExpression",
        "endLine": 534,
        "endColumn": 10,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [config.fields]",
            "fix": { "range": [17136, 17138], "text": "[config.fields]" }
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useGraphQLDataUpdate Hook\n *\n * GraphQL-based replacement for useDataUpdate hook\n * Provides unified state management for data update operations using GraphQL mutations\n * instead of direct Supabase calls.\n *\n * Features:\n * - Product and Supplier CRUD operations via GraphQL\n * - Search functionality using GraphQL queries\n * - Form validation and state management\n * - Error handling for GraphQL errors\n * - UI feedback and confirmation dialogs\n * - Type safety with generated GraphQL types\n */\n\nimport { useState, useCallback, useRef } from 'react';\n// Removed unused imports: useLazyQuery, useMutation\nimport {\n  useCreateProduct,\n  useUpdateProduct,\n  useSearchProductByCode } from '@/lib/graphql/hooks/useProduct';\nimport {\n  useCreateSupplier,\n  useUpdateSupplier,\n  useSearchSuppliers,\n  useSearchSupplierByCode } from '@/lib/graphql/hooks/useSupplier';\n// Import types from the original hook\nexport type FormMode = 'initial' | 'searching' | 'display' | 'edit' | 'add' | 'loading' | 'error';\n\nexport interface FormField {\n  name: string;\n  label: string;\n  type: 'text' | 'number' | 'select' | 'textarea' | 'email';\n  required?: boolean;\n  validation?: (value: unknown) => string | null;\n  placeholder?: string;\n  options?: { value: string; label: string }[];\n}\n\nexport interface FormConfig {\n  fields: FormField[];\n  entityType: 'product' | 'supplier' | 'qc' | 'grn' | 'custom';\n  tableName?: string; // Keep for compatibility but not used\n  primaryKey?: string;\n  validateForm?: (data: Record<string, unknown>) => Record<string, string>;\n}\n\nexport interface FormState {\n  mode: FormMode;\n  data: Record<string, unknown>;\n  originalData: Record<string, unknown> | null;\n  touched: Record<string, boolean>;\n  errors: Record<string, string>;\n  isLoading: boolean;\n  isSearching: boolean;\n  isUpdating: boolean;\n  searchTerm: string;\n  searchResults: Record<string, unknown>[];\n}\n\nexport interface FormActions {\n  // Data management\n  setFieldValue: (field: string, value: unknown) => void;\n  setMultipleFields: (fields: Record<string, unknown>) => void;\n  resetForm: () => void;\n  setFormData: (data: Record<string, unknown>) => void;\n\n  // Mode management\n  setMode: (mode: FormMode) => void;\n  switchToEdit: () => void;\n  switchToAdd: () => void;\n  switchToDisplay: () => void;\n  switchToInitial: () => void;\n\n  // Validation\n  validateField: (field: string) => string | null;\n  validateForm: () => boolean;\n  markFieldTouched: (field: string) => void;\n  markAllFieldsTouched: () => void;\n  clearErrors: () => void;\n  setError: (field: string, error: string) => void;\n\n  // Search operations\n  search: (searchTerm: string) => Promise<void>;\n  setSearchTerm: (term: string) => void;\n\n  // CRUD operations\n  create: () => Promise<boolean>;\n  update: () => Promise<boolean>;\n  delete?: (id: string) => Promise<boolean>;\n\n  // UI helpers\n  showSuccess: (message: string) => void;\n  showError: (message: string) => void;\n  showConfirmation: (message: string, onConfirm: () => void) => void;\n}\n\nexport interface UseGraphQLDataUpdateOptions {\n  config: FormConfig;\n  initialData?: Record<string, unknown>;\n  onSuccess?: (action: 'create' | 'update' | 'delete', data: Record<string, unknown>) => void;\n  onError?: (error: Error, action: string) => void;\n  enableSearch?: boolean;\n  enableConfirmation?: boolean;\n  customValidation?: (data: Record<string, unknown>) => Record<string, string>;\n}\n\nexport interface UseGraphQLDataUpdateReturn {\n  state: FormState;\n  actions: FormActions;\n  config: FormConfig;\n}\n\nexport const useGraphQLDataUpdate = (\n  options: UseGraphQLDataUpdateOptions\n): UseGraphQLDataUpdateReturn => {\n  const {\n    config,\n    initialData = {},\n    onSuccess,\n    onError,\n    enableSearch = true,\n    enableConfirmation = true,\n    customValidation } = options;\n\n  // State management\n  const [state, setState] = useState<FormState>({\n    mode: 'initial',\n    data: { ...initialData },\n    originalData: null,\n    touched: {},\n    errors: {},\n    isLoading: false,\n    isSearching: false,\n    isUpdating: false,\n    searchTerm: '',\n    searchResults: [] });\n\n  // Reference for stable callbacks\n  const stateRef = useRef(state);\n  stateRef.current = state;\n\n  // GraphQL hooks based on entity type\n  const [createProduct] = useCreateProduct();\n  const [updateProduct] = useUpdateProduct();\n  const [searchProductByCode] = useSearchProductByCode();\n\n  const [createSupplier] = useCreateSupplier();\n  const [updateSupplier] = useUpdateSupplier();\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [searchSuppliers] = useSearchSuppliers();\n  const [getSupplierByCode] = useSearchSupplierByCode();\n\n  // Helper to show overlays (same as original)\n  const showOverlay = useCallback(\n    (type: 'success' | 'error' | 'warning', message: string, duration = 3000) => {\n      const overlay = document.createElement('div');\n      overlay._className =\n        'fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm';\n\n      const colorClass =\n        type === 'success'\n          ? 'border-green-500/30 text-green-400'\n          : type === 'error'\n            ? 'border-red-500/30 text-red-400'\n            : 'border-yellow-500/30 text-yellow-400';\n\n      overlay.innerHTML = `\n      <div class=\"bg-slate-800/90 backdrop-blur-md border ${colorClass} rounded-lg p-8 text-center\">\n        <div class=\"text-xl font-bold mb-2\">${message}</div>\n      </div>\n    `;\n\n      document.body.appendChild(overlay);\n      setTimeout(() => overlay.remove(), duration);\n    },\n    []\n  );\n\n  // Field validation (same as original)\n  const validateField = useCallback(\n    (field: string): string | null => {\n      const fieldConfig = config.fields.find(f => f.name === field);\n      const value = stateRef.current.data[field];\n\n      if (!fieldConfig) return null;\n\n      // Required field validation\n      if (fieldConfig.required && (!value || (typeof value === 'string' && !value.trim()))) {\n        return `${fieldConfig.label} is required`;\n      }\n\n      // Custom validation\n      if (fieldConfig.validation) {\n        return fieldConfig.validation(value);\n      }\n\n      // Type-specific validation\n      if (fieldConfig.type === 'email' && value) {\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        if (!emailRegex.test(String(value))) {\n          return `${fieldConfig.label} must be a valid email`;\n        }\n      }\n\n      if (fieldConfig.type === 'number' && value !== '' && value !== null && value !== undefined) {\n        if (isNaN(Number(value))) {\n          return `${fieldConfig.label} must be a number`;\n        }\n      }\n\n      return null;\n    },\n    []\n  );\n\n  // Form validation (same as original)\n  const _validateForm = useCallback((): boolean => {\n    const errors: Record<string, string> = {};\n\n    // Validate each field\n    config.fields.forEach(field => {\n      const error = validateField(field.name);\n      if (error) {\n        errors[field.name] = error;\n      }\n    });\n\n    // Custom form-level validation\n    if (customValidation) {\n      const customErrors = customValidation(stateRef.current.data);\n      Object.assign(errors, customErrors);\n    }\n\n    // Config-level validation\n    if (config._validateForm) {\n      const configErrors = config.validateForm(stateRef.current.data);\n      Object.assign(errors, configErrors);\n    }\n\n    setState(prev => ({ ...prev, errors }));\n    return Object.keys(errors).length === 0;\n  }, [config, customValidation, validateField]);\n\n  // GraphQL Search Operations\n  const search = useCallback(\n    async (searchTerm: string) => {\n      if (!enableSearch || !searchTerm.trim()) {\n        return;\n      }\n\n      setState(prev => ({ ...prev, isSearching: true, searchTerm }));\n\n      try {\n        const primaryKey = config.primaryKey || 'id';\n\n        if (config.entityType === 'product') {\n          // Search for product\n          const result = await searchProductByCode({\n            variables: { code: searchTerm.trim() } });\n\n          if (result.error || !result.data?.product) {\n            // Not found - switch to add mode\n            setState(prev => ({\n              ...prev,\n              mode: 'add',\n              data: { ...initialData, [primaryKey]: searchTerm.trim() },\n              originalData: null,\n              isSearching: false,\n              errors: {} }));\n          } else {\n            // Found - switch to display mode\n            const productData = result.data.product;\n            const mappedData = {\n              code: productData.code,\n              description: productData.description,\n              type: productData.type,\n              colour: productData.colour,\n              standard_qty: productData.standardQty,\n              remark: productData.remark };\n\n            setState(prev => ({\n              ...prev,\n              mode: 'display',\n              data: { ...mappedData },\n              originalData: { ...mappedData },\n              isSearching: false,\n              errors: {} }));\n          }\n        } else if (config.entityType === 'supplier') {\n          // Search for supplier\n          const result = await getSupplierByCode({\n            variables: { code: searchTerm.trim() } });\n\n          if (result.error || !result.data?.supplier) {\n            // Not found - switch to add mode\n            setState(prev => ({\n              ...prev,\n              mode: 'add',\n              data: { ...initialData, [primaryKey]: searchTerm.trim() },\n              originalData: null,\n              isSearching: false,\n              errors: {} }));\n          } else {\n            // Found - switch to display mode\n            const supplierData = result.data.supplier;\n            const mappedData = {\n              supplier_code: supplierData.code,\n              suppliername: supplierData.name };\n\n            setState(prev => ({\n              ...prev,\n              mode: 'display',\n              data: { ...mappedData },\n              originalData: { ...mappedData },\n              isSearching: false,\n              errors: {} }));\n          }\n        }\n      } catch (error) {\n        console.error('GraphQL Search error:', error);\n        setState(prev => ({\n          ...prev,\n          isSearching: false,\n          mode: 'error',\n          errors: { search: 'Failed to search. Please try again.' } }));\n        onError?.(error as Error, 'search');\n      }\n    },\n    [config, enableSearch, initialData, onError, searchProductByCode, getSupplierByCode]\n  );\n\n  // GraphQL Create Operations\n  const create = useCallback(async (): Promise<boolean> => {\n    if (!validateForm()) {\n      return false;\n    }\n\n    setState(prev => ({ ...prev, isUpdating: true }));\n\n    try {\n      if (config.entityType === 'product') {\n        const result = await createProduct({\n          variables: {\n            input: {\n              code: stateRef.current.data.code as string,\n              description: stateRef.current.data.description as string,\n              type: stateRef.current.data.type as string,\n              colour: stateRef.current.data.colour as string,\n              standardQty: stateRef.current.data.standard_qty as number,\n              remark: (stateRef.current.data.remark as string) || null } } });\n\n        if (result.errors) {\n          throw new Error(result.errors[0]?.message || 'Failed to create product');\n        }\n\n        showOverlay('success', 'Product created successfully!');\n        onSuccess?.('create', stateRef.current.data);\n      } else if (config.entityType === 'supplier') {\n        const result = await createSupplier({\n          variables: {\n            input: {\n              code: stateRef.current.data.supplier_code as string,\n              name: stateRef.current.data.suppliername as string } } });\n\n        if (result.errors) {\n          throw new Error(result.errors[0]?.message || 'Failed to create supplier');\n        }\n\n        showOverlay('success', 'Supplier created successfully!');\n        onSuccess?.('create', stateRef.current.data);\n      }\n\n      // Reset form\n      setState(prev => ({\n        ...prev,\n        mode: 'initial',\n        data: { ...initialData },\n        originalData: null,\n        touched: {},\n        errors: {},\n        isUpdating: false,\n        searchTerm: '' }));\n\n      return true;\n    } catch (error) {\n      console.error('GraphQL Create error:', error);\n      showOverlay('error', 'Failed to create record');\n      setState(prev => ({ ...prev, isUpdating: false }));\n      onError?.(error as Error, 'create');\n      return false;\n    }\n  }, [showOverlay, createProduct, createSupplier, config.entityType, initialData, onError, onSuccess]);\n\n  // GraphQL Update Operations\n  const update = useCallback(async (): Promise<boolean> => {\n    if (!config.primaryKey) {\n      console.error('No primary key configured for update operation');\n      return false;\n    }\n\n    if (!validateForm()) {\n      return false;\n    }\n\n    setState(prev => ({ ...prev, isUpdating: true }));\n\n    try {\n      const primaryKey = config.primaryKey;\n      const primaryKeyValue = stateRef.current.data[primaryKey];\n\n      if (!primaryKeyValue) {\n        throw new Error(`No ${primaryKey} found for update`);\n      }\n\n      if (config.entityType === 'product') {\n        const result = await updateProduct({\n          variables: {\n            code: primaryKeyValue as string,\n            input: {\n              description: stateRef.current.data.description as string,\n              type: stateRef.current.data.type as string,\n              colour: stateRef.current.data.colour as string,\n              standardQty: stateRef.current.data.standard_qty as number,\n              remark: (stateRef.current.data.remark as string) || null } } });\n\n        if (result.errors) {\n          throw new Error(result.errors[0]?.message || 'Failed to update product');\n        }\n\n        showOverlay('success', 'Product updated successfully!');\n        onSuccess?.('update', stateRef.current.data);\n      } else if (config.entityType === 'supplier') {\n        const result = await updateSupplier({\n          variables: {\n            code: primaryKeyValue as string,\n            input: {\n              name: stateRef.current.data.suppliername as string } } });\n\n        if (result.errors) {\n          throw new Error(result.errors[0]?.message || 'Failed to update supplier');\n        }\n\n        showOverlay('success', 'Supplier updated successfully!');\n        onSuccess?.('update', stateRef.current.data);\n      }\n\n      // Switch back to display mode with updated data\n      setState(prev => ({\n        ...prev,\n        mode: 'display',\n        originalData: { ...stateRef.current.data },\n        isUpdating: false }));\n\n      return true;\n    } catch (error) {\n      console.error('GraphQL Update error:', error);\n      showOverlay('error', 'Failed to update record');\n      setState(prev => ({ ...prev, isUpdating: false }));\n      onError?.(error as Error, 'update');\n      return false;\n    }\n  }, [showOverlay, updateProduct, updateSupplier, config.entityType, onError, onSuccess]);\n\n  // Action handlers (same as original with GraphQL operations)\n  const actions: FormActions = {\n    // Data management\n    setFieldValue: useCallback((field: string, value: unknown) => {\n      setState(prev => ({\n        ...prev,\n        data: { ...prev.data, [field]: value },\n        touched: { ...prev.touched, [field]: true },\n        errors: { ...prev.errors, [field]: '' }, // Clear field error on change\n      }));\n    }, []),\n\n    setMultipleFields: useCallback((fields: Record<string, unknown>) => {\n      setState(prev => ({\n        ...prev,\n        data: { ...prev.data, ...fields },\n        touched: {\n          ...prev.touched,\n          ...Object.keys(fields).reduce((acc, key) => ({ ...acc, [key]: true }), {}) } }));\n    }, []),\n\n    resetForm: useCallback(() => {\n      setState(prev => ({\n        ...prev,\n        mode: 'initial',\n        data: { ...initialData },\n        originalData: null,\n        touched: {},\n        errors: {},\n        searchTerm: '' }));\n    }, [initialData]),\n\n    setFormData: useCallback((data: Record<string, unknown>) => {\n      setState(prev => ({ ...prev, data: { ...data } }));\n    }, []),\n\n    // Mode management\n    setMode: useCallback((mode: FormMode) => {\n      setState(prev => ({ ...prev, mode }));\n    }, []),\n\n    switchToEdit: useCallback(() => {\n      setState(prev => ({ ...prev, mode: 'edit' }));\n    }, []),\n\n    switchToAdd: useCallback(() => {\n      setState(prev => ({ ...prev, mode: 'add' }));\n    }, []),\n\n    switchToDisplay: useCallback(() => {\n      setState(prev => ({ ...prev, mode: 'display' }));\n    }, []),\n\n    switchToInitial: useCallback(() => {\n      setState(prev => ({ ...prev, mode: 'initial' }));\n    }, []),\n\n    // Validation\n    validateField,\n    _validateForm,\n\n    markFieldTouched: useCallback((field: string) => {\n      setState(prev => ({ ...prev, touched: { ...prev.touched, [field]: true } }));\n    }, []),\n\n    markAllFieldsTouched: useCallback(() => {\n      const touched = config.fields.reduce((acc, field) => ({ ...acc, [field.name]: true }), {});\n      setState(prev => ({ ...prev, touched }));\n    }, []),\n\n    clearErrors: useCallback(() => {\n      setState(prev => ({ ...prev, errors: {} }));\n    }, []),\n\n    setError: useCallback((field: string, error: string) => {\n      setState(prev => ({ ...prev, errors: { ...prev.errors, [field]: error } }));\n    }, []),\n\n    // Search operations\n    search,\n\n    setSearchTerm: useCallback((term: string) => {\n      setState(prev => ({ ...prev, searchTerm: term }));\n    }, []),\n\n    // CRUD operations\n    create,\n    update,\n\n    // UI helpers\n    showSuccess: useCallback(\n      (message: string) => {\n        showOverlay('success', message);\n      },\n      [showOverlay]\n    ),\n\n    showError: useCallback(\n      (message: string) => {\n        showOverlay('error', message);\n      },\n      [showOverlay]\n    ),\n\n    showConfirmation: useCallback(\n      (message: string, onConfirm: () => void) => {\n        if (!enableConfirmation) {\n          onConfirm();\n          return;\n        }\n\n        const overlay = document.createElement('div');\n        overlay._className =\n          'fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm';\n        overlay.innerHTML = `\n        <div class=\"bg-slate-800/90 backdrop-blur-md border border-yellow-500/30 rounded-lg p-8 text-center\">\n          <div class=\"text-yellow-400 text-xl font-bold mb-4\">${message}</div>\n          <div class=\"flex gap-4 justify-center\">\n            <button id=\"confirm-btn\" class=\"px-6 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg\">Confirm</button>\n            <button id=\"cancel-btn\" class=\"px-6 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg\">Cancel</button>\n          </div>\n        </div>\n      `;\n        document.body.appendChild(overlay);\n\n        const confirmBtn = overlay.querySelector('#confirm-btn');\n        const cancelBtn = overlay.querySelector('#cancel-btn');\n\n        confirmBtn?.addEventListener('click', () => {\n          overlay.remove();\n          onConfirm();\n        });\n\n        cancelBtn?.addEventListener('click', () => {\n          overlay.remove();\n        });\n      },\n      [enableConfirmation]\n    ) };\n\n  return {\n    state,\n    actions,\n    config };\n};\n\nexport default useGraphQLDataUpdate;\n",
    "usedDeprecatedRules": []
  }
]
