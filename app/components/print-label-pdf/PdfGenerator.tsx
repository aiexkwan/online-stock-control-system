'use client';

import { pdf, Font } from '@react-pdf/renderer';
// import { PrintLabelPdf, PrintLabelPdfProps } from '../../../components/print-label-pdf/PrintLabelPdf'; // Commented out original import
import { setupStorage, uploadPdf } from '../../../lib/supabase-storage';
import { Dispatch, SetStateAction } from 'react'; // Restored
// import { SupabaseClient } from '@supabase/supabase-js'; // Removed
// import { Database } from '@/lib/database.types'; // Removed
import { Document, Page, Text, View, StyleSheet } from '@react-pdf/renderer'; // Keep for MinimalPdfDoc

// Define a minimal PDF component for testing
const MinimalPdfDoc = () => (
  <Document>
    <Page size="A4">
      <View style={{ padding: 20 }}>
        <Text style={{ fontSize: 24, marginBottom: 10 }}>Minimal PDF Test Document</Text>
        <Text>This is a very simple PDF generated by @react-pdf/renderer.</Text>
        <Text>If you see this, the core PDF generation is working.</Text>
      </View>
    </Page>
  </Document>
);

interface PdfGeneratorProps {
  pdfData: any; // data for the original PrintLabelPdf, not used by MinimalPdfDoc
  fileName: string; // e.g., "some-uuid.pdf"
  folderName: string; // This will be used as palletNum for uploadPdf
  supabase: any; // Supabase client instance, passed from QcLabelForm
  setPdfProgress?: Dispatch<SetStateAction<{ current: number; total: number; status: string[] }>>;
  index?: number;
  onSuccess?: (url: string) => void;
  onError?: (error: Error) => void;
}

export async function generateAndUploadPdf(props: PdfGeneratorProps) {
  console.log('[PdfGenerator] FUNCTION ENTERED');
  const { pdfData, fileName, folderName, supabase, setPdfProgress, index, onSuccess, onError } = props;

  console.log('[PdfGenerator] generateAndUploadPdf called. PalletNum (from folderName):', folderName, 'Output fileName:', fileName);

  // Font registration (optional for minimal test, but good to keep if fonts are used elsewhere or for future)
  try {
    Font.register({
      family: 'Montserrat',
      fonts: [
        { src: '/fonts/Montserrat-Regular.ttf' },
        { src: '/fonts/Montserrat-Bold.ttf', fontWeight: 'bold' },
      ],
    });
    console.log('[PdfGenerator] Font registered (Montserrat).');
  } catch (fontError) {
    console.error('[PdfGenerator] Error registering font:', fontError);
  }

  try {
    console.log('[PdfGenerator] Attempting to generate PDF blob with MinimalPdfDoc...');
    const blob = await pdf(<MinimalPdfDoc />).toBlob();
    console.log('[PdfGenerator] PDF blob generated successfully, size:', blob?.size);

    if (!blob || blob.size === 0) {
      console.error('[PdfGenerator] Generated PDF blob is invalid or empty.');
      throw new Error('Generated PDF blob is invalid or empty');
    }

    console.log('[PdfGenerator] Attempting to setup storage (using global supabase client from supabase-storage.ts)...');
    // setupStorage uses its own imported supabase client, so no need to pass props.supabase here.
    await setupStorage(); // Corrected: No arguments
    console.log('[PdfGenerator] Storage setup hopefully successful. Attempting to upload PDF...');

    // For uploadPdf(palletNum: string, qrValue: string, blob: Blob):
    // Use folderName as palletNum.
    // For qrValue, since MinimalPdfDoc doesn't have a specific QR, we'll derive a placeholder from fileName.
    const qrPlaceholder = fileName.replace('.pdf', ''); // Use the UUID part of the filename as a stand-in for qrValue

    const publicUrl = await uploadPdf(folderName, qrPlaceholder, blob); // Corrected arguments
    console.log('[PdfGenerator] PDF uploaded successfully. Public URL:', publicUrl);

    if (setPdfProgress && typeof index === 'number') {
      setPdfProgress(prev => {
        const newStatus = [...prev.status];
        newStatus[index] = 'Uploaded';
        return { ...prev, current: prev.current + 1, status: newStatus };
      });
    }

    onSuccess?.(publicUrl);
    return publicUrl;

  } catch (error) {
    console.error('[PdfGenerator] Error in PDF generation/upload process:', error);
    if (setPdfProgress && typeof index === 'number') {
      setPdfProgress(prev => {
        const newStatus = [...prev.status];
        newStatus[index] = 'Error';
        return { ...prev, status: newStatus };
      });
    }
    onError?.(error instanceof Error ? error : new Error(String(error)));
    return undefined;
  }
} 