'use client';

import { renderReactPDFToBlob, registerFont } from '@/lib/services/unified-pdf-service';
import {
  PrintLabelPdf,
  PrintLabelPdfProps,
} from '@/components/print-label-pdf/PrintLabelPdf'; // Uncommented original import
import { setupStorage, uploadPdf } from '@/lib/supabase-storage';
import { Dispatch, SetStateAction } from 'react'; // Restored
// import { SupabaseClient } from '@supabase/supabase-js'; // Removed
// import { Database } from '@/lib/database.types'; // Removed
// import { Document, Page, Text, View, StyleSheet } from '@react-pdf/renderer'; // Keep for MinimalPdfDoc

// Define ProgressStatus to match QcLabelForm.tsx
export type ProgressStatus = 'Pending' | 'Processing' | 'Success' | 'Failed';

// MinimalPdfDoc is no longer needed as we are restoring PrintLabelPdf
// const MinimalPdfDoc = () => (
//   <Document>
//     <Page size="A4">
//       <View style={{ padding: 20 }}>
//         <Text style={{ fontSize: 24, marginBottom: 10 }}>Minimal PDF Test Document</Text>
//         <Text>This is a very simple PDF generated by @react-pdf/renderer.</Text>
//         <Text>If you see this, the core PDF generation is working.</Text>
//       </View>
//     </Page>
//   </Document>
// );

interface PdfGeneratorProps {
  pdfData: PrintLabelPdfProps; // Use the specific PrintLabelPdfProps type
  fileName: string; // e.g., "some-uuid.pdf"
  folderName: string; // This will be used as palletNum for uploadPdf
  setPdfProgress?: Dispatch<
    SetStateAction<{ current: number; total: number; status: ProgressStatus[] }>
  >;
  index?: number;
  onSuccess?: (url: string) => void;
  onError?: (error: Error) => void;
}

export async function generateAndUploadPdf(
  props: PdfGeneratorProps
): Promise<{ publicUrl: string; blob: Blob } | undefined> {
  (process.env.NODE_ENV as string) !== 'production' &&
    (process.env.NODE_ENV as string) !== 'production' &&
    console.log('[PdfGenerator] FUNCTION ENTERED');
  const { pdfData, fileName, folderName, setPdfProgress, index, onSuccess, onError } = props;

  (process.env.NODE_ENV as string) !== 'production' &&
    (process.env.NODE_ENV as string) !== 'production' &&
    console.log(
      '[PdfGenerator] generateAndUploadPdf called. PalletNum (from folderName):',
      folderName,
      'Output fileName:',
      fileName
    );

  // Font registration (optional for minimal test, but good to keep if fonts are used elsewhere or for future)
  try {
    await registerFont({
      family: 'Montserrat',
      fonts: [
        { src: '/fonts/Montserrat-Regular.ttf' },
        { src: '/fonts/Montserrat-Bold.ttf', fontWeight: 'bold' },
      ],
    });
    (process.env.NODE_ENV as string) !== 'production' &&
      (process.env.NODE_ENV as string) !== 'production' &&
      console.log('[PdfGenerator] Font registered (Montserrat).');
  } catch (fontError) {
    console.error('[PdfGenerator] Error registering font:', fontError);
  }

  try {
    (process.env.NODE_ENV as string) !== 'production' &&
      (process.env.NODE_ENV as string) !== 'production' &&
      console.log('[PdfGenerator] Attempting to generate PDF blob with PrintLabelPdf...');
    // Use the actual PrintLabelPdf component and pass the pdfData props
    const blob = await renderReactPDFToBlob(<PrintLabelPdf {...pdfData} />);
    (process.env.NODE_ENV as string) !== 'production' &&
      (process.env.NODE_ENV as string) !== 'production' &&
      console.log(
        '[PdfGenerator] PDF blob generated successfully with PrintLabelPdf, size:',
        blob?.size
      );

    if (!blob || blob.size === 0) {
      console.error('[PdfGenerator] Generated PDF blob is invalid or empty.');
      throw new Error('Generated PDF blob is invalid or empty');
    }

    (process.env.NODE_ENV as string) !== 'production' &&
      (process.env.NODE_ENV as string) !== 'production' &&
      console.log(
        '[PdfGenerator] Attempting to setup storage (using global supabase client from supabase-storage.ts)...'
      );
    // setupStorage uses its own imported supabase client, so no need to pass props.supabase here.
    await setupStorage(); // Corrected: No arguments
    (process.env.NODE_ENV as string) !== 'production' &&
      (process.env.NODE_ENV as string) !== 'production' &&
      console.log('[PdfGenerator] Storage setup hopefully successful. Attempting to upload PDF...');

    // For uploadPdf(palletNum: string, qrValue: string, blob: Blob):
    // Use folderName as palletNum.
    // For qrValue, since MinimalPdfDoc doesn't have a specific QR, we'll derive a placeholder from fileName.
    const qrPlaceholder = fileName.replace('.pdf', ''); // Use the UUID part of the filename as a stand-in for qrValue

    const publicUrl = await uploadPdf(folderName, qrPlaceholder, blob); // Corrected arguments
    (process.env.NODE_ENV as string) !== 'production' &&
      (process.env.NODE_ENV as string) !== 'production' &&
      console.log('[PdfGenerator] PDF uploaded successfully. Public URL:', publicUrl);

    if (setPdfProgress && typeof index === 'number') {
      setPdfProgress(prev => {
        const newStatus = [...prev.status];
        newStatus[index] = 'Success'; // Use ProgressStatus type
        return { ...prev, current: prev.current + 1, status: newStatus };
      });
    }

    onSuccess?.(publicUrl);
    return { publicUrl, blob };
  } catch (error) {
    console.error('[PdfGenerator] Error in PDF generation/upload process:', error);
    if (setPdfProgress && typeof index === 'number') {
      setPdfProgress(prev => {
        const newStatus = [...prev.status];
        newStatus[index] = 'Failed'; // Use ProgressStatus type
        return { ...prev, status: newStatus };
      });
    }
    onError?.(error instanceof Error ? error : new Error(String(error)));
    return undefined;
  }
}
