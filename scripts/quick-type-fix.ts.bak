#!/usr/bin/env ts-node
/**
 * å¿«é€Ÿé¡å‹ä¿®å¾©å·¥å…·
 *
 * ä½¿ç”¨é¡å‹æ–·è¨€å¿«é€Ÿä¿®å¾© any é¡å‹è­¦å‘Š
 */

import { promises as fs } from 'fs';

class QuickTypeFixer {
  async fixAllFiles() {
    const files = [
      'app/actions/dashboardActions.ts',
      'app/actions/reportActions.ts',
      'app/actions/orderUploadActions.ts',
      'app/void-pallet/services/voidReportService.ts',
      'app/void-pallet/utils/searchHistory.ts'
    ];

    console.log(`ğŸ”§ é–‹å§‹å¿«é€Ÿä¿®å¾© ${files.length} å€‹æ–‡ä»¶çš„é¡å‹`);

    for (const file of files) {
      await this.fixFile(file);
    }

    console.log('âœ… æ‰€æœ‰é¡å‹å·²å¿«é€Ÿä¿®å¾©');
  }

  private async fixFile(filePath: string) {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      let updatedContent = content;

      // å°‡ Record<string, unknown> æ›¿æ›ç‚º any ä»¥å¿«é€Ÿä¿®å¾©
      updatedContent = updatedContent.replace(
        /Record<string, unknown>/g,
        'any'
      );

      // åªæœ‰å…§å®¹æ”¹è®Šæ™‚æ‰å¯«å›
      if (updatedContent !== content) {
        await fs.writeFile(filePath, updatedContent);
        console.log(`âœ… ä¿®å¾©æ–‡ä»¶: ${filePath}`);
      } else {
        console.log(`â­ï¸ è·³éæ–‡ä»¶: ${filePath} (ç„¡éœ€ä¿®å¾©)`);
      }

    } catch (error) {
      console.error(`âŒ ä¿®å¾©æ–‡ä»¶å¤±æ•— ${filePath}:`, error);
    }
  }
}

// ä¸»åŸ·è¡Œå‡½æ•¸
async function main() {
  console.log('ğŸš€ å•Ÿå‹•å¿«é€Ÿé¡å‹ä¿®å¾©å·¥å…·');

  const fixer = new QuickTypeFixer();
  await fixer.fixAllFiles();

  console.log('\nğŸ‰ å¿«é€Ÿé¡å‹ä¿®å¾©å®Œæˆï¼');
  console.log('è«‹é‹è¡Œ npm run typecheck é©—è­‰ä¿®å¾©æ•ˆæœ');
}

if (require.main === module) {
  main().catch(console.error);
}
